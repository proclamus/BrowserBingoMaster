<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Bingo Master</title>
    <style>
        :root { --primary: #2196F3; --secondary: #FF9800; --bg: #f4f7f6; --success: #4CAF50; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); margin: 0; display: flex; flex-direction: column; align-items: center; }
        .screen { display: none; width: 100%; max-width: 600px; padding: 20px; box-sizing: border-box; }
        .active { display: block; }
        .card-ui { background: white; padding: 20px; border-radius: 15px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); margin-bottom: 20px; }
        .input-group { margin-bottom: 15px; }
        label { display: block; font-size: 14px; margin-bottom: 5px; color: #555; font-weight: bold; }
        input, select { width: 100%; padding: 12px; border: 1px solid #ddd; border-radius: 8px; box-sizing: border-box; font-size: 16px; }
        button { width: 100%; padding: 15px; border: none; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; margin-top: 10px; transition: 0.2s; }
        .btn-blue { background: var(--primary); }
        .btn-orange { background: var(--secondary); }
        .btn-back { background: #666; }
        .big-number { font-size: 80px; font-weight: bold; color: var(--secondary); text-align: center; margin: 10px 0; line-height: 1; }
        .history { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 15px; background: #eee; padding: 12px; border-radius: 8px; max-height: 120px; overflow-y: auto; border: 1px solid #ddd; }
        .history-item { background: white; padding: 4px 10px; border-radius: 5px; font-size: 13px; border: 1px solid #ccc; font-weight: bold; }
        .grid { display: grid; gap: 4px; background: #bbb; padding: 4px; border-radius: 4px; margin-top: 10px; }
        .cell { background: white; aspect-ratio: 1/1; display: flex; align-items: center; justify-content: center; font-weight: bold; cursor: pointer; position: relative; font-size: clamp(10px, 4vw, 16px); }
        .cell.marked::after { content: "X"; color: rgba(255,0,0,0.7); position: absolute; font-size: 2em; font-weight: bold; z-index: 3; }
        
        /* Casa BINGO (Centro) */
        .cell.free-space { background: #fff3e0; color: #e65100; font-size: 0.7em; cursor: default; }
        
        /* Casa Bloqueada (Vazia) */
        .cell.blocked { background: #e0e0e0; cursor: default; opacity: 0.6; }
        .cell.blocked::before { content: ""; width: 80%; height: 1px; background: #aaa; position: absolute; transform: rotate(45deg); }

        .line-h::before { content: ""; position: absolute; width: 100%; height: 4px; background: rgba(76, 175, 80, 0.5); z-index: 2; }
        .line-v::after { content: ""; position: absolute; height: 100%; width: 4px; background: rgba(76, 175, 80, 0.5); z-index: 2; }
        .bingo-win-msg { color: var(--success); text-align: center; font-weight: bold; font-size: 22px; display: none; margin-bottom: 10px; animation: bounce 0.5s infinite alternate; }
        @keyframes bounce { from { transform: scale(1); } to { transform: scale(1.1); } }
    </style>
</head>
<body>

    <div id="menu" class="screen active">
        <div class="card-ui">
            <h2 style="text-align: center; color: var(--primary);">Browser Bingo Master</h2>
            <div class="input-group"><label>N M√°ximo (Sorteio)</label><input type="number" id="maxN" value="75"></div>
            <div class="input-group"><label>Total de N√∫meros na Cartela</label><input type="number" id="totalCells" value="13"></div>
            <div class="input-group">
                <label>Quantidade de Cartelas</label>
                <select id="cardQty"><option value="1">1</option><option value="2">2</option><option value="3">3</option><option value="4">4</option></select>
            </div>
            <div class="input-group">
                <label>Ordena√ß√£o</label>
                <select id="orderMode"><option value="H">Horizontal</option><option value="V">Vertical</option></select>
            </div>
            <button class="btn-blue" onclick="initGame()">GERAR CARTELAS</button>
            <button class="btn-orange" onclick="openSorteador()">ABRIR SORTEADOR</button>
        </div>
    </div>

    <div id="sorteador" class="screen">
        <div class="card-ui">
            <h3 style="text-align: center;">Sorteador</h3>
            <div id="numDisplay" class="big-number">--</div>
            <div id="statusMsg" style="color:red; text-align:center; font-weight:bold;"></div>
            <button id="drawBtn" class="btn-orange" onclick="drawNext()">SORTEAR</button>
            <div id="historyBox" class="history"></div>
            <button class="btn-back" onclick="goTo('menu')">VOLTAR</button>
        </div>
    </div>

    <div id="game" class="screen">
        <div id="cardsArea"></div>
        <button class="btn-back" onclick="goTo('menu')">SAIR</button>
    </div>

    <script>
        let pool = [], drawnNumbers = [];
        function goTo(id) { document.querySelectorAll('.screen').forEach(s => s.classList.remove('active')); document.getElementById(id).classList.add('active'); }

        function openSorteador() {
            const n = parseInt(document.getElementById('maxN').value) || 75;
            pool = Array.from({length: n}, (_, i) => i + 1);
            drawnNumbers = [];
            document.getElementById('numDisplay').innerText = "--";
            document.getElementById('historyBox').innerHTML = "";
            document.getElementById('statusMsg').innerText = "";
            document.getElementById('drawBtn').disabled = false;
            goTo('sorteador');
        }

        function drawNext() {
            if (pool.length === 0) return;
            const idx = Math.floor(Math.random() * pool.length);
            const num = pool.splice(idx, 1)[0];
            drawnNumbers.push(num);
            document.getElementById('numDisplay').innerText = num;
            const sorted = [...drawnNumbers].sort((a,b) => a - b);
            document.getElementById('historyBox').innerHTML = sorted.map(n => `<span class="history-item">${n}</span>`).join('');
            if (pool.length === 0) { document.getElementById('statusMsg').innerText = "Fim!"; document.getElementById('drawBtn').disabled = true; }
        }

        function initGame() {
            const totalRequested = parseInt(document.getElementById('totalCells').value) || 24;
            const nMax = parseInt(document.getElementById('maxN').value) || 75;
            const qty = parseInt(document.getElementById('cardQty').value);
            const mode = document.getElementById('orderMode').value;
            
            let size = Math.ceil(Math.sqrt(totalRequested));
            // Caso especial: se for um n√∫mero √≠mpar central (ex 24), a grade vira 5x5 mas o c√°lculo de n√∫meros considera a casa livre
            let isOddGrid = size % 2 !== 0;
            let middleIdx = isOddGrid ? Math.floor((size * size) / 2) : -1;
            
            // Quantas casas a grade total tem
            let gridTotalCapacity = size * size;
            // Descontando a casa BINGO se houver
            let usableCapacity = isOddGrid ? gridTotalCapacity - 1 : gridTotalCapacity;

            if (totalRequested > usableCapacity) {
                size++;
                gridTotalCapacity = size * size;
                isOddGrid = size % 2 !== 0;
                middleIdx = isOddGrid ? Math.floor((size * size) / 2) : -1;
            }

            const area = document.getElementById('cardsArea');
            area.innerHTML = "";
            for (let i = 0; i < qty; i++) {
                area.appendChild(createBingoCard(nMax, size, mode, totalRequested, middleIdx));
            }
            goTo('game');
        }

        function createBingoCard(nMax, size, mode, totalRequested, middleIdx) {
            const cardContainer = document.createElement('div');
            cardContainer.className = 'card-ui';
            const winMsg = document.createElement('div');
            winMsg.className = 'bingo-win-msg'; winMsg.innerText = "üéâ BINGO! üéâ";
            const grid = document.createElement('div');
            grid.className = 'grid';
            grid.style.gridTemplateColumns = `repeat(${size}, 1fr)`;

            // 1. Decidir quais √≠ndices ser√£o BLOQUEADOS
            let gridIndices = Array.from({length: size * size}, (_, i) => i);
            let blockedIndices = [];
            
            // Se houver casa BINGO, ela n√£o conta como bloqueada nem como n√∫mero
            let availableForNumbers = [...gridIndices];
            if (middleIdx !== -1) availableForNumbers = availableForNumbers.filter(i => i !== middleIdx);

            let excess = availableForNumbers.length - totalRequested;
            
            // L√≥gica de remo√ß√£o: Alterna Topo-Esquerda (0) e Baixo-Direita (fim)
            let useStart = true;
            for(let i=0; i<excess; i++) {
                let targetIdx;
                if(useStart) {
                    targetIdx = availableForNumbers.shift(); // Tira do in√≠cio
                } else {
                    targetIdx = availableForNumbers.pop(); // Tira do fim
                }
                blockedIndices.push(targetIdx);
                useStart = !useStart;
            }

            // 2. Gerar n√∫meros para as casas que sobraram
            let nums = [];
            while(nums.length < totalRequested) {
                let r = Math.floor(Math.random() * nMax) + 1;
                if(!nums.includes(r)) nums.push(r);
            }
            nums.sort((a,b) => a - b);

            // 3. Montar estrutura final das c√©lulas
            let finalCells = new Array(size * size);
            // Marcar BINGO
            if (middleIdx !== -1) finalCells[middleIdx] = { type: 'free', val: 'BINGO' };
            // Marcar Bloqueadas
            blockedIndices.forEach(idx => finalCells[idx] = { type: 'blocked', val: '' });
            
            // Preencher o resto com 'num'
            let nPointer = 0;
            if(mode === 'H') {
                for(let i=0; i<finalCells.length; i++) {
                    if(!finalCells[i]) finalCells[i] = { type: 'num', val: nums[nPointer++] };
                }
            } else {
                for(let col=0; col<size; col++) {
                    for(let row=0; row<size; row++) {
                        let idx = row * size + col;
                        if(!finalCells[idx]) finalCells[idx] = { type: 'num', val: nums[nPointer++] };
                    }
                }
            }

            // 4. Renderizar
            finalCells.forEach((data, index) => {
                const cell = document.createElement('div');
                cell.className = 'cell';
                if(data.type === 'free') {
                    cell.classList.add('free-space', 'marked');
                    cell.innerHTML = "‚≠ê<br>BINGO";
                } else if(data.type === 'blocked') {
                    cell.classList.add('blocked');
                } else {
                    cell.innerText = data.val;
                    cell.onclick = () => {
                        cell.classList.toggle('marked');
                        checkWin(grid, size, winMsg);
                    };
                }
                grid.appendChild(cell);
            });

            cardContainer.appendChild(winMsg);
            cardContainer.appendChild(grid);
            return cardContainer;
        }

        function checkWin(grid, size, winMsg) {
            const cells = grid.querySelectorAll('.cell');
            cells.forEach(c => { c.classList.remove('line-h'); c.classList.remove('line-v'); });
            
            let totalToMark = 0;
            let markedCount = 0;

            for (let i = 0; i < size; i++) {
                let row = [], col = [];
                for (let j = 0; j < size; j++) {
                    row.push(i * size + j);
                    col.push(j * size + i);
                }
                // S√≥ valida linha se todos os n√∫meros clic√°veis nela estiverem marcados
                // Casas BLOQUEADAS s√£o ignoradas na checagem de linha completa
                if (checkLine(row, cells)) row.forEach(idx => cells[idx].classList.add('line-h'));
                if (checkLine(col, cells)) col.forEach(idx => cells[idx].classList.add('line-v'));
            }

            cells.forEach(c => {
                if(!c.classList.contains('blocked')) {
                    totalToMark++;
                    if(c.classList.contains('marked')) markedCount++;
                }
            });
            winMsg.style.display = (markedCount === totalToMark) ? 'block' : 'none';
        }

        function checkLine(indices, cells) {
            // Uma linha/coluna s√≥ conta se tiver pelo menos uma casa √∫til (n√£o bloqueada)
            let hasActiveCell = indices.some(idx => !cells[idx].classList.contains('blocked'));
            if (!hasActiveCell) return false;

            return indices.every(idx => {
                let c = cells[idx];
                return c.classList.contains('blocked') || c.classList.contains('marked');
            });
        }
    </script>
</body>
</html>
